import React, { Component, PropTypes } from 'react';
import { shallowEqual } from './PureRender';
import { getDisplayName, findAllByType } from './ReactUtils';
import { getStackedDataOfItem, getTicksOfAxis,
	getBarSizeList, getBarPosition } from './CartesianUtils';
import { getBandSizeOfScale } from './DataUtils';

export default ({ getComposedData, ChildComponent }) => (WrappedComponent) =>
  class ComposedDataDecorator extends Component {
    static displayName = `ComposedDataDecorator(${getDisplayName(WrappedComponent)})`;

    static propTypes = {
      ...WrappedComponent.propTypes,
      chartX: PropTypes.number,
      chartY: PropTypes.number,
      data: PropTypes.array,
    };

    // static WrappedComponent = WrappedComponent;

    static defaultProps = WrappedComponent.defaultProps;

    state = { composedData: this.getAllComposedData() };

    /**
     * @return {Array} the composedData
		 *		{axisTicks, points, baseLine, layout} for each graphicalItem in
     * props
     */
    getAllComposedData() {
      const { children, graphicalItems, xAxisMap, yAxisMap, stackGroups,
              layout, offset, barSize, barGap, barCategoryGap } = this.props;

      // Some charts pre-filter their items into the graphicalItems prop,
      // others filter it in render of the children
      const items = graphicalItems || findAllByType(children, ChildComponent);

      const sizeList = getBarSizeList({ barSize, stackGroups });

      const allComposedData = [];
      items.forEach((item) => {
        const { xAxisId, yAxisId, dataKey } = item.props;
        let xAxis, yAxis, xTicks, yTicks, axisTicks, barPosition, stackedData;
        if (xAxisMap || yAxisMap) {

          xAxis = xAxisMap[xAxisId];
          yAxis = yAxisMap[yAxisId];

          xTicks = getTicksOfAxis(xAxis);
          yTicks = getTicksOfAxis(yAxis);
          axisTicks = layout === 'horizontal' ? xTicks : yTicks;

          const numericAxisId = layout === 'horizontal' ? yAxisId : xAxisId;
          const cateAxisId = layout === 'horizontal' ? xAxisId : yAxisId;
          const cateAxis = layout === 'horizontal' ? xAxisMap[xAxisId] : yAxisMap[yAxisId];
          stackedData = stackGroups && stackGroups[numericAxisId] &&
            stackGroups[numericAxisId].hasStack &&
            getStackedDataOfItem(item, stackGroups[numericAxisId].stackGroups);

          const bandSize = getBandSizeOfScale(cateAxis.scale);
          barPosition =
            getBarPosition({ barGap, barCategoryGap, bandSize, sizeList: sizeList[cateAxisId] });
        }

        const composedData = getComposedData && getComposedData({ props: this.props,
          xAxis, yAxis, xTicks, yTicks, dataKey, item, barPosition, offset, stackedData,
        }) || {};
        composedData.axisTicks = axisTicks;
        allComposedData.push(composedData);
      });

      return allComposedData;
    }

	/*
	* Update the state of the composedData if anything relevant changed
	*/
	/* eslint-disable no-unused-vars */
    componentWillReceiveProps({ graphicalItems, children, chartX, chartY,
      activeTooltipIndex, isTooltipActive, ...restNextProps }) {

      const { graphicalItems: graphicalItemsOld, children: childrenOld,
      chartX: chartXOld, chartY: chartYOld, activeTooltipIndex: aTIOld,
      isTooltipActive: iTAOld, ...restOldProps } = this.props;

    /* eslint-enable no-unused-vars */

      if (!shallowEqual(graphicalItems, graphicalItemsOld) ||
          !shallowEqual(children, childrenOld) ||
          !shallowEqual(restNextProps, restOldProps)) {
        this.setState({ composedData: this.getAllComposedData() });
      }
    }

	/*
	 * Ignore the state generated by getAllComposedData when determining
	 * whether to update
	 */
    shouldComponentUpdate({ graphicalItems, ...restProps }) {
		// props.graphicalItems is sometimes generated every time -
		// check that specially as object equality is likely to fail
      const { graphicalItems: graphicalItemsOld, ...restPropsOld } = this.props;
      return !shallowEqual(graphicalItems, graphicalItemsOld) ||
			!shallowEqual(restProps, restPropsOld);
    }

    render() {
      return <WrappedComponent {...this.props} composedData={this.state.composedData} />;
    }
  };
